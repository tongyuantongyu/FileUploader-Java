# Java 大作业报告

[https://fileuploader.tyty.moe](https://fileuploader.tyty.moe)

## 项目简介

本项目为一个多线程文件传输工具。主要解决从本地向服务器上传文件时既有的传输协议在网络环境不佳时速度慢，效果差的问题。本项
目初为本人一个使用C++语言完成的项目，在本次大作业中由本人编写了Java版本，实现了两个版本间的协议兼容，并依托Java的跨平台
特性扩展了整个工具的可能使用场景。

## 需求分析

文件传输，不论是上传还是下载，都是网络相关操作中极为常见的行为。对于下载，服务端常常使用HTTP/FTP等协议，对于不要求及时性
的文件下载任务，往往可以借用这些协议部分传输的特性，建立多个连接进行传输，从而加快总体的文件传输速度。但相同的技术在上传
操作中则并不常见，如SCP仅能够以单线程传输文件，在复杂的网络条件下速度常常不理想，漫长的等待时间无疑是对工作效率的极大拖
累。使用本地计算机作为服务端，远程服务器作为客户端进行下载是一种解决方案，但因现实网络环境复杂，用户本地网络常在NAT后，
无法作为服务端被动接受连接，故此方法有较大的局限性。本程序则着眼于解决以上问题，首先借鉴了下载加速手法中建立多个连接的思
想，并通过协议设计解决了下载加速中变长文件分割难以实现以及协议重新建立连接消耗大量时间拖累尾期速度的缺点，并在传输过程中
引入加密算法，提供了一个安全高速的文件传输方案。

## 程序设计

整个程序分为两个部分，客户端部分和服务端部分。其中，客户端部分提供了CLI和GUI两种执行方式，分别满足不同场景下的文件传输需
求；而服务端部分考虑到绝大多数服务器不具有桌面环境，故仅提供CLI执行方式。协议层面保证与客户端与服务端均可与C++版本互通，
且Java版本自身保证互通，以增加程序兼容度。

## 问题与解决方案

### 文件读写方案
旧的```java.io```包中的文件库的读写方法偏移量参数```off```的类型为```int```，这将导致程序无法处理现代文件系统中大小大于
4GB的大型文件；这使得我必须选择使用新的```java.nio```包中的库。在经过考虑之后，我选择了异步类```AsynchronousFileChannel```
来进行读写操作。```AsynchronousFileChannel```是对底层系统异步I/O接口的封装，可以提供较高的性能。此外，程序发出读写请求的
时间点和真正需要数据的时间点也有一定的间隔，使用异步文件管道亦可以充分利用这一段时间，提高效率。

### 异步调用处理
本程序在设计上天生需要大量的I/O线程操作，是典型的I/O密集型程序，故而在Socket通信上，有必要使用异步的调用，以保证文件传输
的效率。为此我选用了```AsynchronousServerSocketChannel```和```AsynchronousSocketChannel```类，进行异步编程。Java的异步调
用有两种模式，一种是使用```CompletionHandler```或lambda处理回调，另一种则是返回```Future```对象供调用。但两种方式都有一
定的不足，使用回调的方式会破坏原有的代码逻辑，使执行流混乱；而```Future```对象在等待时则会造成阻塞，影响效率。为此，我选
择了```ea.async```库，这个库借鉴了来自.NET的async/await语法，底层则将await转化为基于回调的代码，既避免了大量回调对代码结
构的破坏，也避免了阻塞对程序效率的影响。

### 解决高内存占用问题
在最终发布前调试时，我注意到在尝试上传巨型文件时，服务端JVM会使用大量的内存，最终导致Heap区OutOfMemory。通过向JVM添加
```-XX:+PrintGC```参数，我发现约占文件大小两倍的内存无法被GC清理。在研究后我发现文件写入调用返回的```Future```对象持有写
入数据和文件缓存的两份引用，而程序写入部分为了提高写入调用的效率而将```Future```对象直接保存在Vector中等待文件关闭时统一
调用```get()```方法确保写入完毕，导致了大量缓存引用无法被及时回收释放内存。为此我重构了```Writer```代码，改为使用基于回
调的写入方式，抑制了内存占用。经测试，在使用16线程和64K块大小的配置下，服务端可以仅使用16MB堆内存正常运行。

## 性能测试

为了检验本程序对加速文件传输的真实效果，我使用clumsy工具在客户端与服务端间添加可控的网络不稳定因素，借此评估程序对文件传
输的加速效果。
本测试使用OpenJDK 13.0.1运行，固定块大小64K，客户端服务端均分配2G堆内存，传输1GB的随机内容文件，以此评估文件传输的性能。
评估源文件来自内存盘，目标为NVMe SSD，尽可能减小磁盘I/O对潜在性能的限制。

|        |        1T       |        4T       |       16T       |       256T      |
|:------:|:---------------:|:---------------:|:---------------:|:---------------:|
|  Ideal |  273MB/s, 1.00x |  656MB/s, 2.40x |  403MB/s, 1.48x |  294MB/s, 1.08x |
|  Good  | 4.02MB/s, 1.00x | 24.8MB/s, 6.17x | 81.7MB/s, 20.3x |  129MB/s, 32.1x |
| Normal | 1.14MB/s, 1.00x | 6.31MB/s, 5.56x | 22.8MB/s, 20.1x | 91.4MB/s, 80.4x |
|   Bad  |  129KB/s, 1.00x |  591KB/s, 4.60x | 1.43MB/s, 11.4x | 7.78MB/s, 62.0x |

注：

Ideal: 本地环回地址的理想网络环境

Good: 模拟50ms延迟, 0.5%丢包率网络环境

Normal: 模拟120ms延迟, 3%丢包率网络环境

Bad: 模拟250ms延迟, 10%丢包率, 1%机率发生10ms连续丢包网络环境


从列表数据可以看出，在理想环境下，少量增加线程数可以提高传输速度，但主要是对硬盘（SSD）读写速度的提升；而在模拟现实的网
络环境下，单线程传输的速度则出现了极大的滑坡，而多线程则在一定范围内带来了接近线性的速度提升，且对于质量越差的网络环境，
提速效果越为显著。
总而言之，本程序确实达到了提高文件上传速度的目的。

## 开发，管理与发布

本项目使用maven作为项目管理及构建工具，使用Git进行版本控制，所有代码以MIT协议开源，请参见[GitHub Repository](https://github.com/tongyuantongyu/FileUploader-Java)。
